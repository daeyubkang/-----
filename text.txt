#구간 합 구하기1 11659
sys.stdin.readline -> 반복문으로 여러 줄을 입력 받아야 할 때 input()으로 입력 받으면 시간초과가 발생할 수 있기 때문에 sys.stdin.readline을 사용. 정수로 활용할 때는 형변환에 유의. 한 줄 단위 입력이라 개행문자가 포함되는 점 유의
구간 합은 합 배열을 이용해서 시간복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
prefix_sum을 이름으로 한 합 배열 선언 이후 prefix_sum.append로 데이터 값 저장
이 문제의 핵심은 합 배열의 활용이라고 생각

#구간 합 구하기2 11660
파이썬은 배열 선언이 다르다
여기서 배열은 [n+1][n+1]로 선언하는 것이 포인트
합 배열을 계산할 때 수식 중요


#나머지 합 구하기 10986
https://www.acmicpc.net/problem/10986
처음 생각한대로 코딩해 제출 하였더니 시간 초과가 발생했다. 내 예상으로는 중첩 for문은 쓰면 시간 초과가 발생하는 듯하다.
책을 참고하여 푼 방식은 합 배열을 생성, 그 값마다 나머지를 구하여 새로운 배열에 추가 
또 하나의 배열을 생성하는데 나머지 값을 인덱스로 두고, 인덱스에 속하는 데이터에 값이 나올 때마다 1씩 추가 
해당 값이 1이상이면 구간 합의 특성을 이용하여 2개씩 묶어 count를 계산.
구간 합의 특성을 이해해야 한다. 

#연속된 자연수의 합 구하기 2018
https://www.acmicpc.net/problem/2018
파이썬은 조건문을 활용하여 반복 루프를 돌릴 때 while문을 사용하는 것이 유용
input을 받을 때 정수로 활용하려면 형 변환이 필요
이 문제는 단순하지만 복잡도를 최소한으로 하는 것이 중요
문제의 조건에 따라 바로 출제자가 원하는 알고리즘을 떠오르게 반복 수련의 필요

#주몽의 명령 1940
정렬 후 비교하며 탐색
sort() 정렬

#DNA 비밀번호 12891
슬라이딩 윈도우를 사용하는 문제
기존의 검사결과에서 새로 들어온 문자열, 제거되는 문자열만 반영하여 확인하는 것이 핵심

#최솟값 찾기1 11003
덱을 사용하여 슬라이싱 윈도우 수행
sort를 사용하면 시간초과 발생
덱은 인덱스와 값을 저장 가능
덱은 양방향 append, pop 수행 가능 
덱의 값이나 인덱스를 호출할 때 사용하는 방법은 공부 필요

#스택으로 수열 만들기 1874
스택의 특성은 후입선출이다. 그릇모양으로 생각
이 문제는 num 변수를 잘 이용하는 것이 중요하다고 생각된다.

#오큰수 구하기 17298
스택에 인덱스를 쌓아가며 계산을 해야한다.
while문을 잘 이해해야 한다.
스택을 잘 응용하려면 많은 학습이 필요할 듯하다.
while문을 돌면서 원하는 값을 대입

#카드게임 2164
덱의 특성을 이용하여 풀면 간단하게 나온다.
popleft() appendleft() pop() append()

#절댓값 힙 구현하기 11286
우선순위 큐를 사용하여 구현하면 단순하게 풀린다.

#버블정렬 프로그램1 1377
sort와 sorted의 차이 구분
리스트에 인덱스를 저장하여 정렬 후에 인덱스 차이가 큰 값으로 리턴

#ATM 인출 시간 게산하기 11399
합한 값을 다시 한 번 더하는 for문이 필요

#수 정렬하기3 10989
sort를 사용하면 시간 초과 발생 따라서 계수 정렬을 사용해야한다.
계수 정렬이란 인덱스를 n으로 두고 input된 수만큼 추가하여 1부터 문제에 주어진 최댓값까지의 배열 중 0이 아닌 값을 출력하여 정렬하는 방식
문제에서 주는 숫자를 참고하여 무슨 알고리즘을 사용할 지 결정

#20, 21 다시 풀어보기

#연결 요소의 개수 구하기 11724
깊이 우선 탐색(dfs)는 파이썬에서 재귀함수로 이용이 많이 된다.
인접리스트와 방문리스트를 구현하여 방문했던 노드는 다시 방문하지 않는 다는 것을 주의하며 코딩해야 한다.

#신기한 소수 찾기 2023
소수판별을 해주는 함수를 생성하고 소수일 때마다 덱에 추가한다.
한 자리수의 for문을 돌면 그 전 자리수는 덱에서 삭제를 해주어야하기 때문에
popleft()를 써주어 삭제를 해주었다. 

#친구 관계 파악하기 13023
재귀함수를 구현하여 문제를 해결한다.
해당 노드를 방문을 하였는지 분간하는 리스트를 만들어서 확인한다.
연결된 노드의 수를 depth에 저장하고 depth가 5가되면 리턴하고 for문을 break 시킨다.
재귀함수를 구현할 때 함수를 어느 부분에서 호출할 지가 중요하고 함수를 호출하지 않았을 때의 끝맺음도 중요하다.

#DFS와 BFS 프로그램 #1260
DFS와 BFS의 차이를 아는 것이 중요하다
DFS는 깊이우선탐색으로 재귀함수를 사용하여 구현하고
BFS는 너비우선탐색으로 큐를 사용하여 구현한다.

#미로 탐색하기 2178
BFS의 특징을 사용해서 덱을 이용하여 푼다.
이 문제는 x좌표와 y좌표의 활용 또한 중요
BFS와 DFS 모두 방문 리스트가 필수적으로 필요하다
지금까지 본 BFS 문제의 특징은 덱을 사용하여 덱이 빌 때까지 while문을 돌리며 사용하는 것이다.
따라서 popleft 사용으로 먼저 들어온 값을 빼내어 활용하는 것이 중요 
BFS 문제를 더 풀어봐야 익숙해지고 더 넓은 방향으로 응용할 수 있을 거 같다.

#트리의 지름 구하기 1167
트리의 구조를 이해하는 것이 가장 중요
트리의 구조를 이해하고 푸니 예외의 상황이 많이 줄어들었다
2차원 리스트 안에 튜플을 생성하여 목적노드와 가중치를 저장했다.
리스트 안의 튜플을 접근하는 방법에 대해서 공부할 수 있는 좋은 기회였다
런타임에러가 떠서 멘탈이 매우 흔들렸지만 알고보니 입력 상황에서 노드 순으로 입력 받지 않는다는 점 때문이었다.

#원하는 정수 찾기 1920
이진탐색을 사용하여 풀면 된다.
while 문을 사용할 때 break를 많이 사용하기 보다는 while 조건을 타이트하게 하여 푸는 것이 중요하다고 생각된다. 

#블루레이 만들기 2343
리스트를 m의 개수로 나누려고 하지 말고 블루레이의 최솟값을 범위 내에서 이진탐색으로 푸는 것이 중요하다.
이 때 while문을 돌려도 m의 개수로 나누어 떨어지지 않는 반례가 존재하는데 이 때는 마지막 middle 값을 리턴하여 출력한다.

#배열에서 k번째 수 찾기 1300
다시 풀어보기

#동전 개수의 최솟값 구하기 11047
그리디 알고리즘의 대표적인 문제이다
k보다 작은 수 중 가장 큰 값을 나눗셈의 몫만큼 곱하여 동전의 개수를 구한다.

#카드정렬 하기 1715
우선순위 큐는 알아서 정렬되기 때문에 이를 이용하면 편하다
우선순위 큐는 큐와 함수 이름이 달라서 숙지가 필요하다.

#수를 묶어서 최댓값 만들기 1744
잊고 있었던 continue문
우선순위 큐의 편함을 다시한번 느꼈다

#회의실 배정하기 1931
종료시간을 기준으로 정렬하고 for문을 돌리는 게 핵심이다.

#최솟값을 만드는 괄호 배치 찾기 1541
'-'를 기준으로 리스트를 나누고 리스트 안에서 '+'를 기준으로 나눠서 연산을 수행한다.
형변환을 주의해서 풀어야하는 문제이다.

#소수 구하기 1929
에라토스테네스의 체 방식으로 구현
이 방식을 사용할 때 n의 제곱근 까지만 사용하면 된다.

#거의 소수 1456
제곱근까지의 소수를 구한 후에 count를 정한다.
count를 할 때 주의할 점은 조건문을 두 번 써서 구해야하는 점이다.

#소수 팰린드롬 수 중에서 최솟값 찾기 1747
덱 자료구조의 특성을 이용하여 처음 수와 마지막 수를 비교하였다
또 입력 받을 수가 1,000,000 이하 이기 때문에 1,000,000까지의 소수를 모두 구한다.
입력 받은 수 이상의 수 중에서 조건을 만족하는 값이 없을 시에는 1003001을 동일하게 출력한다.

#제곱이 아닌 수 찾기 1016
max의 최댓값이 1조라서 어떤 알고리즘을 써야할 지 고민이 됐는데
에라토스테네스의 체 방식으로 구현할 때는 제곱근까지만 반복하기 때문에
수가 확 줄어들어 이 방식을 활용하여 구현할 수 있었다.

#오일러 피 함수 구현하기 11689
소수 판별을 하고 그것을 활용하여 문제를 푸는 건줄 알았지만 그게 아니었다
n을 계속 소수로 나누어 마지막 값은 소수만을 남게하는 것이 핵심이라고 생각된다.

#칵테일 만들기 1033
왜 틀렸는지 모르겠다
책에는 DFS를 사용하여 풀었지만 잘 이해가 가지 않았다

#Ax + Bx = C 21568
확장 유클리드 호제법의 핵심 이론을 이용해서 풀었다
ax + bx = c 에서 c%gcd(a,b)를 만족하면 정수해를 가진다.
이 방식을 이용해서 풀 때 x,y를 구하는 방식을 최대공약수를 구하는 재귀함수가 풀리면서 x',y'을 리턴받은 값으로 얻을 수 있다.
x = y' y = x'-y'*q 여기서 q는 몫이다.
초기 x',y'값은 1,0을 대입한다.
최종 리턴 받은 값에 c//gcd(a,b)를 곱하면 최초 방정식의 해가 나온다.

#특정 거리의 도시 찾기 18352
BFS와 DFS는 다르다
BFS는 재귀함수 호출로 푸는 것이 아니라 덱 자료구조를 이용해서 푸는 것이다.
재귀함수 호출로 풀었을 때 테스트 예제도 다 맞고 예상되는 반례들도 없었다
하지만 제출 하였더니 런타임에러가 나왔다. 이유는 아직 모르겠지만 bfs방식으로 풀지 않아서 그런 것 같다
뒤에 dfs문제를 더 풀어보고 bfs와의 차이를 더 공부하면 왜 런타임에러가 났는 지 알 수 있을 것 같다.
문제에서 차이점을 파악하고 알고리즘을 고르는 것이 중요할 듯 싶다.

#효율적으로 해킹하기 1325
1. bfs와 dfs의 차이를 명확히 알고 타깃이 무엇인지 정확히 인지 후 알고리즘 선택
2. bfs를 사용할 시에는 방문 리스트 변화를 값을 삽입할 때 실행
3. python과 pypy 차이 구분 python으로 메모리 초과가나도 pypy로는 안 날 수 있음
4. 코드에 변화를 주고 제출할 때는 반드시 실행을 시켜보고 제출

#이분 그래프 1707
이분 그래프는 정점이 모두 연결 되어 있지 않아도 된다.
재귀함수에서 리턴을 할 때는 그 함수에서만 리턴 되는 것이다 한번에 리턴되어 지는 게 아니다
사이클을 판별할 때는 그룹을 두가지로 나누어 쉽게 판별할 수 있다 어렵게 생각하지 말자

#물의 양 구하기 2251
다시 풀어보기

#집합 표현하기
union-find를 사용하는 문제이다
나는 union 할 때도 find 함수를 사용해야하는 지 몰라서 틀렸다
그리고 find 함수의 핵심은 경로 압축이다.

#여행 계획 짜기 1976
유니온 파인드 연산을 해서 푸는 문제이다
유니온 파인드를 사용할 때 파인드 함수를 적절한 시기에 사용하고
매개변수를 잘 사용해서 시간복잡도를 줄이는 게 핵심이다.

#거짓말쟁이가 되긴 싫어 1043
union-find 사용
역시 find 함수의 사용이 핵심 요소 
이 문제의 경우 n만큼 find 다시 수행 
다른 문제들은 어땟는지 다시 확인 필요
마지막 union이 끝나면 모든 항목 find 필