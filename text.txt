#구간 합 구하기1 11659
sys.stdin.readline -> 반복문으로 여러 줄을 입력 받아야 할 때 input()으로 입력 받으면 시간초과가 발생할 수 있기 때문에 sys.stdin.readline을 사용. 정수로 활용할 때는 형변환에 유의. 한 줄 단위 입력이라 개행문자가 포함되는 점 유의
구간 합은 합 배열을 이용해서 시간복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘
prefix_sum을 이름으로 한 합 배열 선언 이후 prefix_sum.append로 데이터 값 저장
이 문제의 핵심은 합 배열의 활용이라고 생각

#구간 합 구하기2 11660
파이썬은 배열 선언이 다르다
여기서 배열은 [n+1][n+1]로 선언하는 것이 포인트
합 배열을 계산할 때 수식 중요


#나머지 합 구하기 10986
https://www.acmicpc.net/problem/10986
처음 생각한대로 코딩해 제출 하였더니 시간 초과가 발생했다. 내 예상으로는 중첩 for문은 쓰면 시간 초과가 발생하는 듯하다.
책을 참고하여 푼 방식은 합 배열을 생성, 그 값마다 나머지를 구하여 새로운 배열에 추가 
또 하나의 배열을 생성하는데 나머지 값을 인덱스로 두고, 인덱스에 속하는 데이터에 값이 나올 때마다 1씩 추가 
해당 값이 1이상이면 구간 합의 특성을 이용하여 2개씩 묶어 count를 계산.
구간 합의 특성을 이해해야 한다. 

#연속된 자연수의 합 구하기 2018
https://www.acmicpc.net/problem/2018
파이썬은 조건문을 활용하여 반복 루프를 돌릴 때 while문을 사용하는 것이 유용
input을 받을 때 정수로 활용하려면 형 변환이 필요
이 문제는 단순하지만 복잡도를 최소한으로 하는 것이 중요
문제의 조건에 따라 바로 출제자가 원하는 알고리즘을 떠오르게 반복 수련의 필요

#주몽의 명령 1940
정렬 후 비교하며 탐색
sort() 정렬

#DNA 비밀번호 12891
슬라이딩 윈도우를 사용하는 문제
기존의 검사결과에서 새로 들어온 문자열, 제거되는 문자열만 반영하여 확인하는 것이 핵심

#최솟값 찾기1 11003
덱을 사용하여 슬라이싱 윈도우 수행
sort를 사용하면 시간초과 발생
덱은 인덱스와 값을 저장 가능
덱은 양방향 append, pop 수행 가능 
덱의 값이나 인덱스를 호출할 때 사용하는 방법은 공부 필요

#스택으로 수열 만들기 1874
스택의 특성은 후입선출이다. 그릇모양으로 생각
이 문제는 num 변수를 잘 이용하는 것이 중요하다고 생각된다.

#오큰수 구하기 17298
스택에 인덱스를 쌓아가며 계산을 해야한다.
while문을 잘 이해해야 한다.
스택을 잘 응용하려면 많은 학습이 필요할 듯하다.
while문을 돌면서 원하는 값을 대입

#카드게임 2164
덱의 특성을 이용하여 풀면 간단하게 나온다.
popleft() appendleft() pop() append()

#절댓값 힙 구현하기 11286
우선순위 큐를 사용하여 구현하면 단순하게 풀린다.

#버블정렬 프로그램1 1377
sort와 sorted의 차이 구분
리스트에 인덱스를 저장하여 정렬 후에 인덱스 차이가 큰 값으로 리턴

#ATM 인출 시간 게산하기 11399
합한 값을 다시 한 번 더하는 for문이 필요

#수 정렬하기3 10989
sort를 사용하면 시간 초과 발생 따라서 계수 정렬을 사용해야한다.
계수 정렬이란 인덱스를 n으로 두고 input된 수만큼 추가하여 1부터 문제에 주어진 최댓값까지의 배열 중 0이 아닌 값을 출력하여 정렬하는 방식
문제에서 주는 숫자를 참고하여 무슨 알고리즘을 사용할 지 결정

#20, 21 다시 풀어보기

#연결 요소의 개수 구하기 11724
깊이 우선 탐색(dfs)는 파이썬에서 재귀함수로 이용이 많이 된다.
인접리스트와 방문리스트를 구현하여 방문했던 노드는 다시 방문하지 않는 다는 것을 주의하며 코딩해야 한다.

#신기한 소수 찾기 2023
소수판별을 해주는 함수를 생성하고 소수일 때마다 덱에 추가한다.
한 자리수의 for문을 돌면 그 전 자리수는 덱에서 삭제를 해주어야하기 때문에
popleft()를 써주어 삭제를 해주었다. 

#친구 관계 파악하기 13023
재귀함수를 구현하여 문제를 해결한다.
해당 노드를 방문을 하였는지 분간하는 리스트를 만들어서 확인한다.
연결된 노드의 수를 depth에 저장하고 depth가 5가되면 리턴하고 for문을 break 시킨다.
재귀함수를 구현할 때 함수를 어느 부분에서 호출할 지가 중요하고 함수를 호출하지 않았을 때의 끝맺음도 중요하다.

#DFS와 BFS 프로그램 #1260
DFS와 BFS의 차이를 아는 것이 중요하다
DFS는 깊이우선탐색으로 재귀함수를 사용하여 구현하고
BFS는 너비우선탐색으로 큐를 사용하여 구현한다.

#미로 탐색하기 2178
BFS의 특징을 사용해서 덱을 이용하여 푼다.
이 문제는 x좌표와 y좌표의 활용 또한 중요
BFS와 DFS 모두 방문 리스트가 필수적으로 필요하다
지금까지 본 BFS 문제의 특징은 덱을 사용하여 덱이 빌 때까지 while문을 돌리며 사용하는 것이다.
따라서 popleft 사용으로 먼저 들어온 값을 빼내어 활용하는 것이 중요 
BFS 문제를 더 풀어봐야 익숙해지고 더 넓은 방향으로 응용할 수 있을 거 같다.

#트리의 지름 구하기 1167
트리의 구조를 이해하는 것이 가장 중요
트리의 구조를 이해하고 푸니 예외의 상황이 많이 줄어들었다
2차원 리스트 안에 튜플을 생성하여 목적노드와 가중치를 저장했다.
리스트 안의 튜플을 접근하는 방법에 대해서 공부할 수 있는 좋은 기회였다
런타임에러가 떠서 멘탈이 매우 흔들렸지만 알고보니 입력 상황에서 노드 순으로 입력 받지 않는다는 점 때문이었다.

#원하는 정수 찾기 1920
이진탐색을 사용하여 풀면 된다.
while 문을 사용할 때 break를 많이 사용하기 보다는 while 조건을 타이트하게 하여 푸는 것이 중요하다고 생각된다. 
